"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[348],{1374:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=t(4848),i=t(8453);const a={},r="Schema Management",o={id:"Guides/schema-management",title:"Schema Management",description:"Schema management for the Cardano PostgreSQL database is a little more complicated than we would",source:"@site/docs/Guides/schema-management.md",sourceDirName:"Guides",slug:"/Guides/schema-management",permalink:"/cardano-db-sync/Guides/schema-management",draft:!1,unlisted:!1,editUrl:"https://github.com/sgillespie/cardano-db-sync/tree/docs/docusaurus/doc/docusaurus/docs/Guides/schema-management.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pool OffChain Data",permalink:"/cardano-db-sync/Guides/pool-offchain-data"},next:{title:"Troubleshooting",permalink:"/cardano-db-sync/Guides/troubleshooting"}},d={},c=[{value:"Creating a Migration",id:"creating-a-migration",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"schema-management",children:"Schema Management"}),"\n",(0,s.jsx)(n.p,{children:"Schema management for the Cardano PostgreSQL database is a little more complicated than we would\nlike, but the scheme chosen allows for easy development, evolution and management of the database."}),"\n",(0,s.jsx)(n.p,{children:"The database schema is defined in four stages, each stage consisting of one or more SQL migrations.\nThe stages are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stage 1"}),": introduces basic postgres types. These cannot be modified or extended."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stage 2"}),": introduces basic tables and their constraints. ",(0,s.jsx)(n.code,{children:"13.1.0.x"})," brings many\nchanges here, as it removes foreign, unique keys and a few fields. These files cannot\nbe modified or extended."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stage 3"}),": introduces only the indexes necessary to db-sync. Having unecessary\nindexes during syncing slows down db-sync and so they are added later. Index\ncreation is idempotent and the ",(0,s.jsx)(n.code,{children:"schema_version.stage_tree"})," field is ignored.\nThese files cannot be modified but they can be extended, in case users want to\nintroduce their own indexes from the begining."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"stage 4"}),": introduces all the other indexes. By default these are the indexes\nthat were created by previous db-sync versions. This stage is executed when\ndb-sync has reached 30mins before the tip of the chain. It is advised to increase\nthe ",(0,s.jsx)(n.code,{children:"maintenance_work_mem"})," from Postgres config to 0.5GB - 1GB to speed this\nprocess (default is 64MB). Also use the default (2) or higher\n",(0,s.jsx)(n.code,{children:"max_parallel_maintenance_workers"}),". These files can be modified or extended\nby users."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'All of the schema migrations in these three stages are written to be idempotent (so that they\n"know" if they have already been applied).'}),"\n",(0,s.jsx)(n.p,{children:"The migration files all have file names of the form:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"migration-1-0000-20190730.sql\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where the ",(0,s.jsx)(n.code,{children:"1"}),' denotes "stage 1" of the SQL migration, the ',(0,s.jsx)(n.code,{children:"0000"})," is the migration version and the\nlast number is the date. Listing the directory containing the schema and sorting the list will\norder them in the correct order for applying to the database."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-migration",children:"Creating a Migration"}),"\n",(0,s.jsxs)(n.p,{children:["Whenever the Haskell schema definition in ",(0,s.jsx)(n.code,{children:"Cardano.Db.Schema"})," is updated, a schema migration will need to be migrated.\nWhen migrating, ",(0,s.jsx)(n.code,{children:"db-sync"})," caches some of the schema files when it is built so this can be point of confusion."]}),"\n",(0,s.jsx)(n.p,{children:"Firstly you need to run current existing migrations by:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export PGPASSFILE=config/pgpass-mainnet\ncabal run cardano-db-tool -- run-migrations --mdir schema/\n"})}),"\n",(0,s.jsx)(n.p,{children:"Next it's time to generated the new migration file by running:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export PGPASSFILE=config/pgpass-mainnet\ncabal run cardano-db-tool -- create-migration --mdir schema/\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will generate a migration if one is needed."}),"\n",(0,s.jsxs)(n.p,{children:["Once this has completed it's good practice to rebuild ",(0,s.jsx)(n.code,{children:"cardano-db-sync"})," due to how it caches schema files when built, this can be done using the following documentation ",(0,s.jsx)(n.a,{href:"./installing.md#build-and-install",children:"Build and Install"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),"  For extra reassurance one can run the test suite to check that the new migration hasn't broken any tests:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"cd ./cardano-chain-gen\ncabal run test:cardano-chain-gen\n"})})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);